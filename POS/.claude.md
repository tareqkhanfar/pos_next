# Claude Code Rules for POS Next

This file contains project-specific rules and conventions for Claude Code when working on the POS Next application.

## API Call Patterns

### Rule: Use Different API Patterns Based on File Type

**Vue Components (.vue files)** → **MUST use `createResource` from frappe-ui**

```javascript
// ✅ CORRECT - Vue Component
import { createResource } from 'frappe-ui'

const myResource = createResource({
	url: 'frappe.client.get_list',
	makeParams() {
		return {
			doctype: 'Customer',
			fields: ['name', 'customer_name']
		}
	},
	auto: false,
	onSuccess(data) {
		// Handle success
	},
	onError(error) {
		// Handle error
	}
})

// Use in template
<Button @click="myResource.reload()" :loading="myResource.loading">
```

**JavaScript Utilities (.js files)** → **MUST use `window.frappe.call`**

```javascript
// ✅ CORRECT - JavaScript Utility
export async function fetchData() {
	try {
		const response = await window.frappe.call({
			method: 'frappe.client.get_list',
			args: {
				doctype: 'Customer',
				fields: ['name', 'customer_name']
			}
		})
		return response.message
	} catch (error) {
		console.error('Error:', error)
		throw error
	}
}
```

**Rationale:**
- **Vue components** benefit from `createResource`'s reactive loading states, error handling, and lifecycle integration
- **JavaScript utilities** are standalone functions that can directly use Frappe's global API without Vue dependencies

### ❌ INCORRECT Examples

```javascript
// ❌ WRONG - Don't use window.frappe.call in Vue components
<script setup>
async function loadData() {
	const response = await window.frappe.call({...}) // BAD!
}
</script>

// ❌ WRONG - Don't use createResource in JS utilities
import { createResource } from 'frappe-ui' // BAD in .js files!
export const myResource = createResource({...})
```

## Translation

Use the `__` method to translate all text that is displayed to the user.

```vue
	<!-- ❌ WRONG - Non-translatable strings -->
	<template>
		<input type="text" placeholder="This is an input"></input>
		<button @click="alert("Button clicked!")">Click Me</button>
	</template>

	<!-- ✅ CORRECT - Translatable strings -->
	<template>
		<input type="text" :placeholder="__("This is an input")" />
		<button @click="alert(__("Button clicked!"))">{{ __('Click Me') }}</button>
	</template>
```

**ALWAYS** wrap translatable string literals directly within the `__` method.

```vue
	<!-- ❌ WRONG - String literal not marked for translation -->
	<template>
		<p>{{ __(message) }}</p>
	</template>
	<script setup>
		const message = ref("This is a message")
	</script>

	<!-- ✅ CORRECT - String literal marked for translation -->
	<template>
		<p>{{ message }}</p>
	</template>
	<script setup>
		const message = ref(__("This is a message"))
	</script>
```

When appropriate, leverage Frappe's built-in translation system for server-side data to translate messages or object properties.

```vue
	<template>
		<p>{{ __(item.data.label) }}</p>
	</template>
	<script setup>
		const myItem = createResource({
			url: 'api.get_my_item',
			auto: false,
		})	
	</script>
```

### Variables

If there are variables in the string, pass them to `__` as the second argument and in array format. 
In the string, use the positional formatter {0}. Don't split your string into separate blocks of strings and then concatenate them. 
Don't write multi-line strings. Always write your string in a single even if the string is very large.

```vue
	<!-- ❌ WRONG - Don't use template literals -->
	<template>
		<p>{{ __(`This paragraph contains two variables ${myVar} and ${myOtherVar}.`) }}</p>
	</template>

	<!-- ❌ WRONG - Don't split strings -->
	<template>
		<p>{{ __('This paragraph contains two variables ') + myVar + __('and') + myOtherVar + __('.') }}</p>
	</template>

	<!-- ❌ WRONG - Don't use multi-line strings -->
	<template>
		<p>{{ __('This paragraph contains two variables' + 
		'{0} and {1}.', [myVar, myOtherVar]) }}</p>
	</template>

	<!-- ✅ CORRECT - Use positional formatter and pass variables in an array -->
	<template>
		<p>{{ __('This paragraph contains two variables {0} and {1}.', [myVar, myOtherVar]) }}</p>
	</template>
```

### Plural

When a variable determine whether a string is to be pluralized, wrap each form of the entire string in the `__` method.

```vue
	<!-- ❌ WRONG - Don't use a single string as a base for multiple forms -->
	<template>
		<p>{{ __('There {0} {1} items{2}.', [itemCount === 1 ? 'is' : 'are', itemCount, itemCount === 1 ? '' : 's']) }}</p>
	</template>

	<!-- ✅ CORRECT - Use an entire string for each form -->
	<template>
		<p>{{ itemCount === 1 
		? __('There is {0} item.', [itemCount])
		: __('There are {0} items.', [itemCount]) }}</p>
	</template>
```

### Context

A string may have different translations depending on the context. When the meaning may be ambiguous, pass a short descriptor string that clarifies the context to `__` as the third argument.

```vue
	<!-- ❌ WRONG - Ambiguous translation -->
	<template>
		<p>{{ __("Change") }}</p>
	</template>

	<!-- ✅ CORRECT - Context clarifies the appropriate translation -->
	<template>
		<p>{{ __("Change", null, "Coins") }}</p>
	</template>
```

## Error Handling

### Toast Notifications in Vue Components

Use the `useToast` composable for user-facing notifications:

```javascript
import { useToast } from '@/composables/useToast'

// In setup function
const { showSuccess, showError, showWarning } = useToast()

// Success notifications
showSuccess(__('Operation completed successfully'))

// Error notifications
showError(error.message || __('Operation failed'))

// Warning notifications
showWarning(__('Please review your input'))
```

### Never use `window.frappe.msgprint` or `toast.create` from frappe-ui

```javascript
// ❌ WRONG - Don't use Frappe's msgprint
window.frappe.msgprint({
	title: 'Error',
	message: 'Something went wrong'
})

// ❌ WRONG - Don't use frappe-ui toast
import { toast } from 'frappe-ui'
toast.create({
	title: 'Error',
	text: 'Something went wrong'
})

// ✅ CORRECT - Use custom toast composable
import { useToast } from '@/composables/useToast'
const { showError } = useToast()
showError(__('Something went wrong'))
```

## Offline Support

### IndexedDB Boolean Queries

When querying boolean fields in IndexedDB/Dexie, always use `.filter()` instead of `.where().equals()`:

```javascript
// ❌ WRONG - Causes DexieError with boolean values
const items = await db.invoice_queue
	.where('synced').equals(false)
	.toArray()

// ✅ CORRECT - Use filter for boolean values
const items = await db.invoice_queue
	.filter(invoice => invoice.synced === false)
	.toArray()
```

## Component Patterns

### Dialog Accessibility

Always provide screen-reader descriptions for dialogs:

```vue
<template>
	<Dialog v-model="show" :options="{ title: __('Dialog Title'), size: 'md' }">
		<template #body-title>
			<span class="sr-only">{{ __('Description for screen readers') }}</span>
		</template>
		<template #body-content>
			<!-- Dialog content -->
		</template>
	</Dialog>
</template>

<style scoped>
.sr-only {
	position: absolute;
	width: 1px;
	height: 1px;
	padding: 0;
	margin: -1px;
	overflow: hidden;
	clip: rect(0, 0, 0, 0);
	white-space: nowrap;
	border-width: 0;
}
</style>
```

## File Organization

### Component Structure

```
POS/src/
├── components/
│   ├── sale/              # POS sale-related components
│   ├── shift/             # Shift management components
│   └── common/            # Shared components
├── composables/           # Vue composables (useOffline, useInvoice, etc.)
├── pages/                 # Main pages (POSSale, Login, Home)
├── utils/                 # Utility functions (.js files)
│   └── offline/          # Offline-specific utilities
└── router.js             # Vue Router configuration
```

## Code Style

### Prefer Editing Over Creating

- **ALWAYS** prefer editing existing files over creating new ones
- Only create new files when absolutely necessary
- Check for existing similar functionality before creating new components

### No Unnecessary Documentation

- Do NOT create documentation files (*.md) unless explicitly requested
- Do NOT create README files proactively
- Keep inline code comments concise and relevant

### Emoji Usage

- Only use emojis if explicitly requested by the user
- Avoid emojis in code, comments, and commit messages by default

## Database Field Names

### POS Payment Method

The `POS Payment Method` child table does NOT have a `default_account` field. To get the payment account:

```python
# ❌ WRONG
payment_method = frappe.db.get_value(
	"POS Payment Method",
	{"parent": pos_profile, "mode_of_payment": mode_of_payment},
	["default_account", "allow_in_returns"],  # default_account doesn't exist!
	as_dict=1
)

# ✅ CORRECT
# First check if payment method is in POS Profile
payment_method = frappe.db.get_value(
	"POS Payment Method",
	{"parent": pos_profile, "mode_of_payment": mode_of_payment},
	"allow_in_returns"
)

# Then get account from Mode of Payment Account table
mop_account = frappe.db.get_value(
	"Mode of Payment Account",
	{"parent": mode_of_payment, "company": company},
	"default_account"
)
```

### Customer Group Attribute

The standard ERPNext `POS Profile` doctype may not have a `customer_group` field. Always check before accessing:

```python
# ✅ CORRECT
pos_profile_doc = frappe.get_cached_doc("POS Profile", pos_profile)
if hasattr(pos_profile_doc, 'customer_group') and pos_profile_doc.customer_group:
	filters["customer_group"] = pos_profile_doc.customer_group
```

## Offline Implementation

### Critical Rule: Use Web Worker for All Offline Operations

**ALL offline operations MUST run in the Web Worker, not the main thread:**

```javascript
// ✅ CORRECT - Using worker for offline operations
import { offlineWorker } from '@/utils/offline/workerClient'

async function loadData() {
	const cacheReady = await offlineWorker.isCacheReady()
	if (isOffline() || cacheReady) {
		// Worker handles IndexedDB operations in background thread
		const data = await offlineWorker.searchCachedItems()
		return data
	} else {
		// Use server if online and cache not ready
		await serverResource.reload()
	}
}

// ❌ WRONG - Running IndexedDB on main thread
import { searchCachedItems } from '@/utils/offline'
const data = await searchCachedItems() // Blocks UI!
```

**Worker Architecture:**
- `/src/workers/offline.worker.js` - Web Worker handles all IndexedDB operations
- `/src/utils/offline/workerClient.js` - Promise-based API for main thread
- All database, sync, and cache operations run in background thread
- Main thread only handles UI and Frappe API calls

### Critical Rule: Cache-First Data Loading

**Always load from cache first, server second:**

```javascript
// ✅ CORRECT - Cache-first approach using worker
async function loadData() {
	const cacheReady = await offlineWorker.isCacheReady()
	if (isOffline() || cacheReady) {
		// Use cache when offline or cache is available
		const data = await offlineWorker.searchCachedItems()
		return data
	} else {
		// Only use server if online and cache not ready
		await serverResource.reload()
	}
}

// ❌ WRONG - Always trying server first
const resource = createResource({
	url: 'api.get_items',
	auto: true  // This fails when offline!
})
```

### Data Pre-Loading Pattern

**POS must pre-load data when online (still uses main thread for API calls):**

```javascript
import { cacheItemsFromServer, cacheCustomersFromServer } from '@/utils/offline'

onMounted(async () => {
	const cacheReady = await offlineWorker.isCacheReady()
	if (!isOffline() && !cacheReady) {
		// Fetch from server (main thread - uses window.frappe.call)
		const items = await fetchItemsFromServer(posProfile)
		const customers = await fetchCustomersFromServer(posProfile)

		// Cache via worker (background thread)
		await offlineWorker.cacheItems(items)
		await offlineWorker.cacheCustomers(customers)

		// Show success notification
		const { showSuccess } = useToast()
		showSuccess(__("Sync Complete - Data is ready for offline use"))
	}
})
```

### Cache Management Functions (via Worker)

**Available worker methods - ALL run in background thread:**
- `offlineWorker.isCacheReady()` - Check if cache has data
- `offlineWorker.getCacheStats()` - Get cache statistics
- `offlineWorker.searchCachedItems(term, limit)` - Search items in cache
- `offlineWorker.searchCachedCustomers(term, limit)` - Search customers in cache
- `offlineWorker.cacheItems(items)` - Cache items array
- `offlineWorker.cacheCustomers(customers)` - Cache customers array
- `offlineWorker.saveOfflineInvoice(data)` - Save invoice to queue
- `offlineWorker.getOfflineInvoices()` - Get queued invoices
- `offlineWorker.getOfflineInvoiceCount()` - Get queue count
- `offlineWorker.deleteOfflineInvoice(id)` - Delete from queue
- `offlineWorker.checkOffline(browserOnline)` - Check offline status
- `offlineWorker.pingServer()` - Ping server for connectivity
- `offlineWorker.setManualOffline(value)` - Set manual offline mode

### Offline-Aware Composables

**useItems pattern (uses worker):**
```javascript
import { useItems } from '@/composables/useItems'

// In component
const { items, loading, loadItems, checkCacheReady, isOffline } = useItems(posProfile)

// Load items (automatically uses worker for cache operations)
await loadItems()

// Check cache status via worker
const ready = await checkCacheReady()
```

**useOffline pattern (uses worker):**
```javascript
import { useOffline } from '@/composables/useOffline'

const {
	isOffline,
	pendingInvoicesCount,
	saveInvoiceOffline,
	syncPending,
	getCacheStats
} = useOffline()

// All database operations run in worker
await saveInvoiceOffline(invoiceData)
const stats = await getCacheStats()
```

**Cache checking in components:**
```javascript
import { offlineWorker } from '@/utils/offline/workerClient'

// Check via worker (non-blocking)
const { showWarning } = useToast()
const cacheReady = await offlineWorker.isCacheReady()
if (isOffline() && !cacheReady) {
	showWarning(__("Limited Functionality - POS is offline without cached data"))
}
```

## Common Issues & Solutions

### Issue: "Unknown column 'default_account' in 'SELECT'"
**Solution:** Use `Mode of Payment Account` table, not `POS Payment Method`

### Issue: "ValidationError: 'POSProfile' object has no attribute 'customer_group'"
**Solution:** Always use `hasattr()` check before accessing optional fields

### Issue: "DexieError: The parameter is not a valid key"
**Solution:** Use `.filter()` instead of `.where().equals()` for boolean values

### Issue: "Frappe API not available" errors
**Solution:** In Vue components, use `createResource` which handles API availability automatically

### Issue: "POS doesn't work offline"
**Solution:** Ensure data is pre-loaded when online using `cacheItemsFromServer()` and `cacheCustomersFromServer()`

### Issue: "Empty items/customers list"
**Solution:** Use cache-first loading pattern - check `isOffline()` or `isCacheReady()` before loading data

---

*Last Updated: 2025-10-01*
*Project: POS Next - Modern POS System for ERPNext*
*Offline-First Architecture: ✅ Implemented*
